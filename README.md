# JavaAlgorithmTree
Java算法研究

![](https://i.imgur.com/Mpj6E7M.png)

![](https://i.imgur.com/QPYXXqR.png)

Prim算法

![](https://i.imgur.com/KREBxHI.png)

<pre>
贪心算法：
    1）贪心策略
    2）局部最优解
    3）全局最优解
       把所有的局部最优解合成为原来问题的一个最优解(a1,a2, ...)

    物品可分割的装载问题我们称之为背包问题，物品不可分割的装载问题我们称之为0-1背包问题。
    在物品不可分割的情况下，即0-1背包问题，已经不具有贪心算法选择性质，原问题的整体最优解无法通过一些列局部最优的选择得到，
 因此这类问题得到的是近似解。如果一个问题不要求得到最优解而只是需要一个最优解的近似解，则不管该问题有没有贪心选择性质，都可以
 使用贪心算法。

贪心算法典型案例：
    加勒比海盗船问题 （尽可能多的财富）
    阿里巴巴与40大盗 （尽可能多的财富）
    会议日程安排（参加尽可能多的会议）
    最短路径（迪科斯彻）

    最短路径算法解析：
        Dijkstra算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照最短路径求出长度次短的一条路径，直到
    求出从源点到其他各个顶点的最短路径。

    哈夫曼编码
        1952年，数学家D.A.Huffman提出了根据字符在文件中出现的评率，用0,1的数字串表示各字符的最佳编码方式，称为哈夫曼编码，
    哈夫曼编码很好的解决了上述两个关键问题，被广泛应用于数据压缩，尤其是远距离通信和大容量数据存储方面，常用的JPEG图片就是
    采用的哈夫曼编码压缩的。

        哈夫曼编码的基本思想是以字符的使用频率作为权构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是将
    所有要编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子节点的权值，以自底向上的方式，通过n-1次的合并运算后构造一
    棵树，核心思想是权值越大的叶子离跟越近。

        哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值
    为其左右孩子节点权值之和，将新树插入到树的集合中，求解步骤如下：
        1）确定合适的数据结构。编写程序前需要考虑的情况有：
             1)哈夫曼树种没有度为1的节点，则一棵有n个叶子节点的哈夫曼树公有 2n-1 个节点（n-1次的合并，每次产生一个新节点）。
             2）构成哈夫曼树后，为求编码，需从叶子节点出发走一条从叶子到根的路径
             3）译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值，双亲，左孩子，右孩子和结点的信息。
        2）初始化。构造n棵结点为n个字符的单节点树集合 T={t1,t2,t3 ... tn},每棵树只有一个带权的根节点，权值为该字符的使用频率

最小生成树
       如图，如何设计布线，将各个单位连通起来，并且费用是多少呢？
       对于n各顶点的连通图，只需要n-1条边就可以使这个图连通，n-1条边要想保证图连通，就必须不含回路，所以我们只需要找出 n-1条权值
    最小且无回路的边即可。
       概念：
           1）子图：从原图中选中一些顶点和边组成的图，称为原图的子图
           2）生成子图：选中一些边和所有顶点组成的图，称为原图的生成子图
           3）生成树：如果生成子图恰好是一棵树，则称为生成树
           5）最小生成树：权值之和最小的生成树，则称为最小生成树
</pre>