# JavaAlgorithmTree
Java算法研究

![](https://i.imgur.com/Mpj6E7M.png)

![](https://i.imgur.com/QPYXXqR.png)

Prim算法

![](https://i.imgur.com/KREBxHI.png)

<pre>
贪心算法：
    1）贪心策略
    2）局部最优解
    3）全局最优解
       把所有的局部最优解合成为原来问题的一个最优解(a1,a2, ...)

    物品可分割的装载问题我们称之为背包问题，物品不可分割的装载问题我们称之为0-1背包问题。
    在物品不可分割的情况下，即0-1背包问题，已经不具有贪心算法选择性质，原问题的整体最优解无法通过一些列局部最优的选择得到，
 因此这类问题得到的是近似解。如果一个问题不要求得到最优解而只是需要一个最优解的近似解，则不管该问题有没有贪心选择性质，都可以
 使用贪心算法。

贪心算法典型案例：
    加勒比海盗船问题 （尽可能多的财富）
    阿里巴巴与40大盗 （尽可能多的财富）
    会议日程安排（参加尽可能多的会议）
    最短路径（迪科斯彻）

    最短路径算法解析：
        Dijkstra算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照最短路径求出长度次短的一条路径，直到
    求出从源点到其他各个顶点的最短路径。

    哈夫曼编码
        1952年，数学家D.A.Huffman提出了根据字符在文件中出现的评率，用0,1的数字串表示各字符的最佳编码方式，称为哈夫曼编码，
    哈夫曼编码很好的解决了上述两个关键问题，被广泛应用于数据压缩，尤其是远距离通信和大容量数据存储方面，常用的JPEG图片就是
    采用的哈夫曼编码压缩的。

        哈夫曼编码的基本思想是以字符的使用频率作为权构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是将
    所有要编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子节点的权值，以自底向上的方式，通过n-1次的合并运算后构造一
    棵树，核心思想是权值越大的叶子离跟越近。

        哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值
    为其左右孩子节点权值之和，将新树插入到树的集合中，求解步骤如下：
        1）确定合适的数据结构。编写程序前需要考虑的情况有：
             1)哈夫曼树种没有度为1的节点，则一棵有n个叶子节点的哈夫曼树公有 2n-1 个节点（n-1次的合并，每次产生一个新节点）。
             2）构成哈夫曼树后，为求编码，需从叶子节点出发走一条从叶子到根的路径
             3）译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值，双亲，左孩子，右孩子和结点的信息。
        2）初始化。构造n棵结点为n个字符的单节点树集合 T={t1,t2,t3 ... tn},每棵树只有一个带权的根节点，权值为该字符的使用频率

最小生成树
       如图，如何设计布线，将各个单位连通起来，并且费用是多少呢？
       对于n各顶点的连通图，只需要n-1条边就可以使这个图连通，n-1条边要想保证图连通，就必须不含回路，所以我们只需要找出 n-1条权值
    最小且无回路的边即可。
       概念：
           1）子图：从原图中选中一些顶点和边组成的图，称为原图的子图
           2）生成子图：选中一些边和所有顶点组成的图，称为原图的生成子图
           3）生成树：如果生成子图恰好是一棵树，则称为生成树
           5）最小生成树：权值之和最小的生成树，则称为最小生成树
</pre>

合并排序

![](https://i.imgur.com/2RsIgGm.png)

排序算法效率对比

![](https://i.imgur.com/LtZ30bQ.png)

<pre>
分治法
    分治算法的本质就是将一个大规模的问题分解成若干个较小的相同子问题，分而治之。

    什么样的问题才能使用分治算法解决呢？需要满足以下3个条件。
        1）原问题可以分解为若干个规模较小的相同子问题。
        2）子问题相互独立
        3）子问题的解可以合并为原问题的解。

    二分搜索技术：
        问题描述：给定n个元素，这些元素是有序的（假定为升序），从中查找特定元素x
        算法设计：
            将有序序列分成规模大致相等的两部分，然后取中间元素与特定查找元素x进行比较，
        如果x等于中间元素，则查找成功，算法终止；如果x小于中间元素，则在序列的前半部分
        继续查找，即在序列的前半部分重复分解和治理操作；否则，在序列的后半部分继续查找，
        即在序列的后半部分重复分解和治理操作。

        递归调用的二分搜索技术空间复杂度为(log2 n)，时间复杂度为log(2, n)

合并排序
    问题分析：
        合并排序就是采用分治的策略，将一个大的问题分成很多个小问题，先解决小问题，再通过
    小问题解决大问题。由于排序问题给定是一个无序的序列，可以把待排序元素分解成两个规模大致
    相等的子序列，如果不易解决，再将得到的子序列继续分解，知道子序列中包含的元素个数为1。
    因为单个元素的序列本身是有序的，是便可以进行合并，从而得到一个完整的有序序列。

快速排序
    快速排序是比较快速的排序方法，快速排序由Hoare在1962年提出，它的基本思想是通过一组排
    序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要
    小，然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此使
    所有数据编程有序序列
   
       快速排序的算法设计思想：
           1）分解：先从数据列中取出一个元素作为基准元素，以基准元素作为标准，将问题分解为
       两个子序列，使小于或等于 基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
           2）治理: 对两个子序列进行快速排序
           3）合并：将排好序的两个子序列合并在一起，得到原问题的解。

大乘数乘法：  
</pre>

<pre>
动态规划：
       在分治法中各个子问题是互不相交的，如果各个子问题有重叠，不是相互独立的，那么分治法
   就重复求解了很多子问题，根本显现不了分治的优势，反而降低了算法效率，这个时候可以使用动
   态规划。

       算法思想：
           动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干子
       问题，合并子问题的解，从而得到原问题的解。动态规划也是把原问题分解为若干子问题，然后
       自底向上，先求解最小的子问题，把结果存储在表格中，再求解大的子问题，直接从表格中查询
       小的子问题的解，避免重复计算，从而提高算法效率。

   DNA编辑距离
   斐波拉契
   最长公共子序列
   编辑距离
   小石子游戏--石子合并
   大卖场购物车--- 0~1背包问题
   快速定位---最优二叉搜索树

   动态规划的关键总计如下：
       1）最优子结构判定
          1）做出一个选择
          2）假定已经知道了哪种选择是最优的
       2）证明原问题的最优解包含其子问题的最优解
</pre>
