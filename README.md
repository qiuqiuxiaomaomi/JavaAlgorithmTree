# JavaAlgorithmTree
Java算法研究

![](https://i.imgur.com/Mpj6E7M.png)

![](https://i.imgur.com/QPYXXqR.png)

Prim算法

![](https://i.imgur.com/KREBxHI.png)

<pre>
贪心算法：
    1）贪心策略
    2）局部最优解
    3）全局最优解
       把所有的局部最优解合成为原来问题的一个最优解(a1,a2, ...)

    物品可分割的装载问题我们称之为背包问题，物品不可分割的装载问题我们称之为0-1背包问题。
    在物品不可分割的情况下，即0-1背包问题，已经不具有贪心算法选择性质，原问题的整体最优解无法通过一些列局部最优的选择得到，
 因此这类问题得到的是近似解。如果一个问题不要求得到最优解而只是需要一个最优解的近似解，则不管该问题有没有贪心选择性质，都可以
 使用贪心算法。

贪心算法典型案例：
    加勒比海盗船问题 （尽可能多的财富）
    阿里巴巴与40大盗 （尽可能多的财富）
    会议日程安排（参加尽可能多的会议）
    最短路径（迪科斯彻）

    最短路径算法解析：
        Dijkstra算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照最短路径求出长度次短的一条路径，直到
    求出从源点到其他各个顶点的最短路径。

    哈夫曼编码
        1952年，数学家D.A.Huffman提出了根据字符在文件中出现的评率，用0,1的数字串表示各字符的最佳编码方式，称为哈夫曼编码，
    哈夫曼编码很好的解决了上述两个关键问题，被广泛应用于数据压缩，尤其是远距离通信和大容量数据存储方面，常用的JPEG图片就是
    采用的哈夫曼编码压缩的。

        哈夫曼编码的基本思想是以字符的使用频率作为权构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是将
    所有要编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子节点的权值，以自底向上的方式，通过n-1次的合并运算后构造一
    棵树，核心思想是权值越大的叶子离跟越近。

        哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值
    为其左右孩子节点权值之和，将新树插入到树的集合中，求解步骤如下：
        1）确定合适的数据结构。编写程序前需要考虑的情况有：
             1)哈夫曼树种没有度为1的节点，则一棵有n个叶子节点的哈夫曼树公有 2n-1 个节点（n-1次的合并，每次产生一个新节点）。
             2）构成哈夫曼树后，为求编码，需从叶子节点出发走一条从叶子到根的路径
             3）译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值，双亲，左孩子，右孩子和结点的信息。
        2）初始化。构造n棵结点为n个字符的单节点树集合 T={t1,t2,t3 ... tn},每棵树只有一个带权的根节点，权值为该字符的使用频率

最小生成树
       如图，如何设计布线，将各个单位连通起来，并且费用是多少呢？
       对于n各顶点的连通图，只需要n-1条边就可以使这个图连通，n-1条边要想保证图连通，就必须不含回路，所以我们只需要找出 n-1条权值
    最小且无回路的边即可。
       概念：
           1）子图：从原图中选中一些顶点和边组成的图，称为原图的子图
           2）生成子图：选中一些边和所有顶点组成的图，称为原图的生成子图
           3）生成树：如果生成子图恰好是一棵树，则称为生成树
           5）最小生成树：权值之和最小的生成树，则称为最小生成树
</pre>

合并排序

![](https://i.imgur.com/2RsIgGm.png)

排序算法效率对比

![](https://i.imgur.com/LtZ30bQ.png)

<pre>
分治法
    分治算法的本质就是将一个大规模的问题分解成若干个较小的相同子问题，分而治之。

    什么样的问题才能使用分治算法解决呢？需要满足以下3个条件。
        1）原问题可以分解为若干个规模较小的相同子问题。
        2）子问题相互独立
        3）子问题的解可以合并为原问题的解。

    二分搜索技术：
        问题描述：给定n个元素，这些元素是有序的（假定为升序），从中查找特定元素x
        算法设计：
            将有序序列分成规模大致相等的两部分，然后取中间元素与特定查找元素x进行比较，
        如果x等于中间元素，则查找成功，算法终止；如果x小于中间元素，则在序列的前半部分
        继续查找，即在序列的前半部分重复分解和治理操作；否则，在序列的后半部分继续查找，
        即在序列的后半部分重复分解和治理操作。

        递归调用的二分搜索技术空间复杂度为(log2 n)，时间复杂度为log(2, n)

合并排序
    问题分析：
        合并排序就是采用分治的策略，将一个大的问题分成很多个小问题，先解决小问题，再通过
    小问题解决大问题。由于排序问题给定是一个无序的序列，可以把待排序元素分解成两个规模大致
    相等的子序列，如果不易解决，再将得到的子序列继续分解，知道子序列中包含的元素个数为1。
    因为单个元素的序列本身是有序的，是便可以进行合并，从而得到一个完整的有序序列。

快速排序
    快速排序是比较快速的排序方法，快速排序由Hoare在1962年提出，它的基本思想是通过一组排
    序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要
    小，然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此使
    所有数据编程有序序列
   
       快速排序的算法设计思想：
           1）分解：先从数据列中取出一个元素作为基准元素，以基准元素作为标准，将问题分解为
       两个子序列，使小于或等于 基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
           2）治理: 对两个子序列进行快速排序
           3）合并：将排好序的两个子序列合并在一起，得到原问题的解。

大乘数乘法：  
</pre>

<pre>
动态规划：
       在分治法中各个子问题是互不相交的，如果各个子问题有重叠，不是相互独立的，那么分治法
   就重复求解了很多子问题，根本显现不了分治的优势，反而降低了算法效率，这个时候可以使用动
   态规划。

       算法思想：
           动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干子
       问题，合并子问题的解，从而得到原问题的解。动态规划也是把原问题分解为若干子问题，然后
       自底向上，先求解最小的子问题，把结果存储在表格中，再求解大的子问题，直接从表格中查询
       小的子问题的解，避免重复计算，从而提高算法效率。

   DNA编辑距离
   斐波拉契
   最长公共子序列
   编辑距离
   小石子游戏--石子合并
   大卖场购物车--- 0~1背包问题
   快速定位---最优二叉搜索树

   动态规划的关键总计如下：
       1）最优子结构判定
          1）做出一个选择
          2）假定已经知道了哪种选择是最优的
       2）证明原问题的最优解包含其子问题的最优解
</pre>

回溯法求最优解

![](https://i.imgur.com/Rc7xBZL.png)

<pre>
回溯法：
       回溯法是一种选优搜索法，按照选优条件深度优先搜索，以达到目标。当搜索到某一步时，发现
   原先选择并不是最优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术称为回溯法
   ，而满足回溯条件的某个状态称为回溯点。

   算法要素：
       1）解空间
          顾名思义，就是由所有可能的解组成的空间，而我们需要根据问题的约束条件，在解空间
        中寻找最优解。
          解空间越小，搜索效率越高，解空间越大，搜索效率越低。
       2）解空间的组织结构
          一个问题的解空间通常由很多可能解组成，我们不可能毫无章法，像无头苍蝇一样乱飞乱撞
        去寻找最优解，盲目搜索的效率太低了，需要按照一定的套路，即一定的组织结构搜索最优解
        ，如果把这种组织结构用树形象地表达出来，就是解空间树。
       3）搜索解空间
          隐约束指针对能够得到问题的可行解或最优解作出的约束。
          如果不满足隐约束，就说明得不到问题的可行解或最优解，那就没有必要再沿着该节点的
        分支进行搜索了，相当于把 这个分支减掉了，因此，隐约束也称为剪枝函数，实质上不是
        减掉该分支，相当于剪枝了。
          隐约束（剪枝函数）包括约束函数和限界函数。

   大卖场购物车   0~1背包问题
       根据问题，从n个物品中选择一些物品，相当于从n个物品组成的集合S中找到一个子集，这个
     子集内所有的物品的总重量不超过购物车容量，并且这些物品的总价值最大，S的所有的子集都是
     问题的可能解，这些可能解组成了解空间，我们在解空间中找总重量不超过购物车容量且价值最大
     的物品集作为最优解。
       这些由问题的子集组成的解空间，其解空间树称为子集树。

   部落护卫队---最大团

   地图调色板---地图着色

   一山不容二虎---n皇后问题

   机器零件加工--最优加工顺序

   旅行商问题

   
        用回溯法解决问题时，首先要考虑如下3个问题。
        1）定义合适的解空间
           因为解空间的大小对搜索效率有很大的影响，因此使用回溯法首先要定义合适的解空间，
        确定解空间包括解的组织形式和显约束。
           1）解的组织形式：解的组织形式都规范为一个n元祖（x1, x2 ... xn）,只是具体问题
              表达的含义不同而已
           2）显约束
              显约束是对解分量的取值范围的限定，显约束可以控制解空间的大小。
        2）确定解空间的组织结构
           解空间的组织结构通常用解空间树形象的表达，根据解空间树的不同，解空间氛围子集树，
        排列树，m叉树。
        3）搜索解空间
           回溯法是按照深度优先搜索策略，根据隐约束，在解空间中搜索问题的可行解或最优解。当
        发现当前节点不满足求解条件时，就回溯，尝试其他的路径，”能进则进，进不了则退，换不了则退“

           如果问题只是要求可行解，则只需要设定约束函数即可;如果要求最优解，则需要设定约束
        函数和限界函数。
</pre>

<pre>
分支限界法
       从根开始，常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树，首先将
    根节点加入活节点表，接着从活节点表中取出根节点，使其成为当前扩展节点，一次性生成所有孩子
    节点，判断孩子节点是舍弃还是保留，舍弃那些导致不可行解或导致非最优解的孩子节点，其余的
    被保留在活节点表中，再从活节点表中取出一个活节点作为当前扩展节点，重复上述扩展过程，直到
    找到所需的解或者活节点表为空时为止。

    大卖场购物车  0~1背包问题
        
</pre>

![](https://i.imgur.com/3YHrjhG.png)

<pre>
线性规划网络流
       在科学研究，工程设计，经济管理等方面，我们都会碰到最优化决策的实际问题，而解决这类
   问题的理论解除是线性规划。利用线性规划研究的问题，大致可以归纳为两种类型：
       第一种类型：
           给定一定数量的人力，物力资源，求怎样安排这些资源，能使完成的任务量最大或效益最大。
       第二种类型：
           给定一项任务，求怎样统筹安排，能使完成这样任务的人力，物力资源最小

   遇到一个线性规划问题，该如何解决呢？
       1）确定决策变量，即哪些变量对决策目标有影响
       2）确定目标函数，把目标表示为含有决策变量的线性函数，通常目标函数是求最大值或者最小值
       3）找出约束条件，将对决策变量的约束表示未线性方程或不等式
       5）求最优解，求解的方法有很多，例如图解法，单纯形法

       图解法只能解决简单的线性规划问题，因为二维图形很容易画出来，三维就需要一定空间想象
   力了，四维以上就很难用图形表达，因此图解法只能解决一些简单的低维问题，复杂的线性规划问题
   还需要更高的办法来解决。

   增广路算法
</pre>

<pre>
算命先生算法：
    在农村或者小城镇生活的人可能都见过这样一种算命的，他首先会给你8张卡片，上面写满了姓氏，让你从里面找出有你自己姓氏的卡片，当你把所有自己姓氏的卡片给他的时候，他竟然会一口说出你的姓氏。然后你就会相信他后面所说的所有话，当然，拿钱也是毫不犹豫的事情了。 
     不过，只要是读过书的人都知道，这肯定是骗人的，都明白这个道理很简单，不就是在几张卡片中找出相同的姓氏，而且这些卡片中有且仅有一个姓氏是同时存在的。但是，大家有没有想过，一个卡片上有三四十个姓氏，你给他拿去的可能加起来就是100好几个姓氏，他是怎样一眼就看出来的呢？当然，这个也不是难题，不就是给每个卡片、每个姓氏加一个唯一的标示嘛，但仔细一样，要怎样加这个标示呢？又怎么样来快速的辨认这些标示呢？
    学过计算机的人可能一下子就明白了，“二进制”，或许能帮我们解决这个问题。大家都知道一个4位的二进制可以表示16以内任意一个十进制数，那么5位，6位...11111111这个8位的二进制数相当于10进制的255，也就是说一个8位的二进制数可以表示255以内的任意一个十进制数值。那么，我们就不难想到，取出他们的权值“1，2，4，8，16，32，64”，那么255以内的任意一个10进制数值都可以通过这8个数值中的任意个数想加得到。比如说：我们分别为8张卡片（假设为：A1，A2，A3，A4，A5，A6，A7，A8）分配上述8个数值。然后为所有姓氏分配一个唯一的大于0的数值。比如有：赵（1），钱（5），孙（14），李（43），王（90），卢（104）那么我们可以得到如下集合
       A1=“赵，钱，李”；
       A2=“孙，李，王”；
       A3=“钱，孙”；
       A4=“孙，李，王，卢”；
       A5=“王”；
       A6=“李，卢”；
       A7=“王，卢”；
    如果你是个要算命的，你给我拿来A1，A3卡片，我可以很快的算出：1+4=5，既“钱”；拿来A4，A6，A7，那就是“8+32+64=104” 既“卢”。异词类推，想必大家都已经豁然开朗。如果想通过计算机实现此功能也就相当简单了，只是对每个姓氏对应的数值转换成2进制，然后根据它的权值就可以确定这个字应该放在那些卡片里，然后把选出的卡片的值想加，再查询响应的姓氏就搞定了。
    由此我们可以清楚的认识到，不管是算命还是魔术或者其他，“骗人”只是众人的一种叫法，其实，它只是科学知识的另一种用途而已，所以，不管遇到什么让我们难以想象的事情，如果仔细想想，或许能通过自己所学来揭开它的迷团
</pre>

谷歌15道智力题
<pre>
村子里有100对夫妻，其中每个丈夫都瞒着自己的妻子偷情。村子里的每个妻子都能立即发现除自己
丈夫之外的其他男人是否偷情，维度不知道她自己的丈夫到底有没有偷情。村子里的规矩是不容忍通
奸。任何一个妻子，一旦能证明自己的男人偷情，就必须当天把他杀死。村里的女人严格按照规矩办事，一天
，女头领出来宣布，村里至少有一个丈夫偷情，请问接下来会发生什么事？
</pre>

<pre>
假设在一段高速公路上，30分钟之内见到汽车经过的概率是0.95。那么，在10分钟内见到汽车经过的
概率是多少?(假设缺省概率固定)

答案：这题的关键在于0.95是见到一辆或多辆汽车的概率，而不是仅见到一辆汽车的概率。在30分
钟内，见不到任何车辆的概率为0.05。因此在10分钟内见不到任何车辆的概率是这个值的立方根，
而在10分钟内见到一辆车的概率则为1减去此立方根，也就是大约63%。
</pre>

<pre>
有四个人要在夜里穿过一条悬索桥回到宿营地。可是他们只有一支手电，电池只够再亮17分钟。过桥
必须要有手电，否则太危险。桥最多只能承受两个人 同时通过的重量。这四个人的过桥速度都不一样：
一个需要1分钟，一个需要2分钟，一个需要5分钟，还有一个需要10分钟。他们如何才能在17分钟之
内全部 过桥？

答案：1和2一起过(2分钟);1返回(3分钟);5和10一起过(13分钟);2返回(15分钟);1和2一起过(17分钟)。全体安全过桥。
</pre>

<pre>
假设你在衣橱里挂满衬衫，很难从中挑出某一件来。请问你打算怎样整理一下，使得它们容易挑选？

答案：此题没有固定答案。考验的是被面试者在解决问题方面的想象力和创造性。我们觉得读者
”Dude”的这个答案可能会给Google留下深刻印象：把它们按布料的种类进行哈希(HASH)组合。
然后每类再按2-3-4树或红黑树(都是计算机算法)排序
</pre>

<pre>
为1万亿个数排序需要多长时间?请说出一个靠谱的估计。

答案：这又是一个没有标准答案的题目。目的是考察被面试者的创造性。我们倾向于两位读者给出的简单
答案：用归并排序法(Merge Sort)排序。平均情况下为O(1,000,000,000,000 Log 1,000,000,000,000)。
最差情况下为O(1,000,000,000,000 Log 1,000,000,000,000)。
现在可以做到每秒10亿次的运算，所以大约应需要3000秒。
</pre>

<pre>
给你一个数字链表。链表到头之后又会从头开始(循环链表)。请写出寻找链表中最小数字的最高效算法。
找出此链表中的任意给定数字。链表中的 数字总是不断增大的，但是你不知道循环链表从何处开始。
例：38, 40, 55, 89, 6, 13, 20, 23, 36。

答案：我们最喜欢的答案来自读者”dude”：建立临时指针并从根上开始。(循环链表大多数情况下都有
向前或向后指针。)判断是向前更大还是向后更 大。如果向前更大则知道已达到链表最后，又重新位于
链表开始位置。如果向前更大，那你可以向后搜寻并进行数字比较。如果既没有根也没有指针指向链表，
那么 你的数据就丢失在内存中了。
</pre>

